<!DOCTYPE html>
<html>
<head>
  <title>Flow Lenia 3D Viewer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #111;
      color: #fff;
      font-family: system-ui, sans-serif;
      overflow: hidden;
    }
    #container { width: 100vw; height: 100vh; }
    #controls {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 8px;
      z-index: 100;
    }
    #controls input[type="file"] { margin-bottom: 10px; }
    #controls label { display: block; margin: 8px 0 4px; font-size: 12px; }
    #controls input[type="range"] { width: 200px; }
    #info {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 8px;
      font-size: 12px;
      font-family: monospace;
    }
    button {
      background: #333;
      color: #fff;
      border: 1px solid #555;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 5px;
    }
    button:hover { background: #444; }
    button.active { background: #0066cc; border-color: #0088ff; }
  </style>
</head>
<body>
  <div id="container"></div>

  <div id="controls">
    <input type="file" id="fileInput" accept=".flwa">
    <div>
      <button id="playBtn">Play</button>
      <button id="resetBtn">Reset</button>
    </div>
    <label>Frame: <span id="frameNum">0</span></label>
    <input type="range" id="frameSlider" min="0" max="100" value="0">
    <label>Opacity: <span id="opacityVal">0.5</span></label>
    <input type="range" id="opacitySlider" min="0" max="1" step="0.05" value="0.5">
    <label>Threshold: <span id="threshVal">0.05</span></label>
    <input type="range" id="threshSlider" min="0" max="0.5" step="0.01" value="0.05">
  </div>

  <div id="info">Drop a .flwa file or use the file picker</div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    // FLWA Parser
    class FLWAParser {
      static async parse(buffer) {
        const view = new DataView(buffer);
        let offset = 0;

        // Magic
        const magic = String.fromCharCode(...new Uint8Array(buffer, 0, 4));
        if (magic !== 'FLWA') throw new Error('Invalid FLWA file');
        offset += 4;

        // Version & flags
        const version = view.getUint16(offset, true); offset += 2;
        const flags = view.getUint16(offset, true); offset += 2;
        const compression = flags & 0x0F;

        // Dimensions
        const width = view.getUint32(offset, true); offset += 4;
        const height = view.getUint32(offset, true); offset += 4;
        const depth = view.getUint32(offset, true); offset += 4;
        const channels = view.getUint32(offset, true); offset += 4;

        // Frame info
        const frameCountLow = view.getUint32(offset, true); offset += 4;
        const frameCountHigh = view.getUint32(offset, true); offset += 4;
        const frameCount = frameCountLow; // Assume < 4B frames

        const dt = view.getFloat32(offset, true); offset += 4;
        offset += 16; // Reserved

        // Read frame indices from end of file
        const indexSize = frameCount * 16;
        const indexStart = buffer.byteLength - indexSize;
        const indices = [];
        let idxOffset = indexStart;

        for (let i = 0; i < frameCount; i++) {
          const indexView = new DataView(buffer, idxOffset);
          const frameOffset = Number(indexView.getBigUint64(0, true));
          const frameSize = Number(indexView.getBigUint64(8, true));
          indices.push({ offset: frameOffset, size: frameSize });
          idxOffset += 16;
        }

        // Read all frames
        const gridSize = width * height * depth;
        const frames = [];

        for (let i = 0; i < frameCount; i++) {
          const { offset: frameOffset, size } = indices[i];
          const frameData = new Float32Array(buffer, frameOffset, gridSize * channels);
          // Just take first channel for now
          frames.push(new Float32Array(frameData.slice(0, gridSize)));
        }

        return { width, height, depth, channels, frameCount, dt, frames };
      }
    }

    // Viridis colormap
    const viridisColors = [
      [0.267, 0.004, 0.329],
      [0.282, 0.141, 0.458],
      [0.253, 0.265, 0.529],
      [0.206, 0.371, 0.553],
      [0.163, 0.471, 0.558],
      [0.128, 0.566, 0.550],
      [0.134, 0.658, 0.518],
      [0.266, 0.749, 0.440],
      [0.477, 0.821, 0.318],
      [0.741, 0.873, 0.150],
      [0.993, 0.906, 0.144]
    ];

    function viridis(t) {
      t = Math.max(0, Math.min(1, t));
      const idx = t * (viridisColors.length - 1);
      const low = Math.floor(idx);
      const high = Math.min(low + 1, viridisColors.length - 1);
      const f = idx - low;
      return [
        viridisColors[low][0] + f * (viridisColors[high][0] - viridisColors[low][0]),
        viridisColors[low][1] + f * (viridisColors[high][1] - viridisColors[low][1]),
        viridisColors[low][2] + f * (viridisColors[high][2] - viridisColors[low][2])
      ];
    }

    // App state
    let animation = null;
    let currentFrame = 0;
    let playing = false;
    let opacity = 0.5;
    let threshold = 0.05;

    // Three.js setup
    const container = document.getElementById('container');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(100, 100, 100);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x111111);
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Add axis helper and bounding box
    function addAxisHelper(size) {
      // Remove old helpers
      scene.children
        .filter(c => c.userData.isHelper)
        .forEach(c => scene.remove(c));

      const halfSize = size / 2;

      // Bounding box edges
      const boxGeo = new THREE.BoxGeometry(size, size, size);
      const edges = new THREE.EdgesGeometry(boxGeo);
      const lineMat = new THREE.LineBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.5 });
      const box = new THREE.LineSegments(edges, lineMat);
      box.userData.isHelper = true;
      scene.add(box);

      // Axis lines (X=red, Y=green, Z=blue)
      const axisLength = size * 0.6;
      const axes = [
        { dir: [1, 0, 0], color: 0xff4444 },  // X - red
        { dir: [0, 1, 0], color: 0x44ff44 },  // Y - green
        { dir: [0, 0, 1], color: 0x4444ff },  // Z - blue
      ];

      axes.forEach(({ dir, color }) => {
        const points = [
          new THREE.Vector3(-halfSize * dir[0], -halfSize * dir[1], -halfSize * dir[2]),
          new THREE.Vector3(axisLength * dir[0], axisLength * dir[1], axisLength * dir[2])
        ];
        const geo = new THREE.BufferGeometry().setFromPoints(points);
        const mat = new THREE.LineBasicMaterial({ color, linewidth: 2 });
        const line = new THREE.Line(geo, mat);
        line.userData.isHelper = true;
        scene.add(line);
      });

      // Axis labels
      // (would need CSS2DRenderer for text, keeping simple for now)
    }

    // Point cloud for volume visualization
    let pointCloud = null;
    let geometry = null;
    let material = null;

    function createPointCloud(width, height, depth) {
      if (pointCloud) {
        scene.remove(pointCloud);
        geometry.dispose();
        material.dispose();
      }

      const positions = [];
      const colors = [];
      const sizes = [];

      // Center the volume
      const cx = width / 2, cy = height / 2, cz = depth / 2;

      for (let z = 0; z < depth; z++) {
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            positions.push(x - cx, y - cy, z - cz);
            colors.push(0, 0, 0);
            sizes.push(1);
          }
        }
      }

      geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

      material = new THREE.PointsMaterial({
        size: 1.5,
        vertexColors: true,
        transparent: true,
        opacity: opacity,
        sizeAttenuation: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      pointCloud = new THREE.Points(geometry, material);
      scene.add(pointCloud);

      // Add axis helper
      const maxDim = Math.max(width, height, depth);
      addAxisHelper(maxDim);

      // Adjust camera
      camera.position.set(maxDim * 1.5, maxDim * 1.5, maxDim * 1.5);
      controls.target.set(0, 0, 0);
      controls.update();
    }

    function updatePointCloud(frame) {
      if (!geometry || !animation) return;

      const colors = geometry.attributes.color.array;
      const sizes = geometry.attributes.size.array;
      const { width, height, depth } = animation;

      for (let i = 0; i < frame.length; i++) {
        const value = frame[i];

        if (value > threshold) {
          const [r, g, b] = viridis(value);
          colors[i * 3 + 0] = r;
          colors[i * 3 + 1] = g;
          colors[i * 3 + 2] = b;
          sizes[i] = 1.0 + value * 2;
        } else {
          colors[i * 3 + 0] = 0;
          colors[i * 3 + 1] = 0;
          colors[i * 3 + 2] = 0;
          sizes[i] = 0;
        }
      }

      geometry.attributes.color.needsUpdate = true;
      geometry.attributes.size.needsUpdate = true;
      material.opacity = opacity;
    }

    function updateInfo() {
      if (!animation) return;
      const { width, height, depth, frameCount, dt } = animation;
      const time = currentFrame * dt;
      document.getElementById('info').textContent =
        `${width}×${height}×${depth} | Frame ${currentFrame}/${frameCount-1} | Time: ${time.toFixed(2)}s`;
      document.getElementById('frameNum').textContent = currentFrame;
      document.getElementById('frameSlider').value = currentFrame;
    }

    // File loading
    async function loadFile(file) {
      const buffer = await file.arrayBuffer();
      animation = await FLWAParser.parse(buffer);

      document.getElementById('frameSlider').max = animation.frameCount - 1;
      createPointCloud(animation.width, animation.height, animation.depth);
      currentFrame = 0;
      updatePointCloud(animation.frames[0]);
      updateInfo();
    }

    document.getElementById('fileInput').addEventListener('change', (e) => {
      if (e.target.files[0]) loadFile(e.target.files[0]);
    });

    // Drag and drop
    document.body.addEventListener('dragover', (e) => e.preventDefault());
    document.body.addEventListener('drop', (e) => {
      e.preventDefault();
      if (e.dataTransfer.files[0]) loadFile(e.dataTransfer.files[0]);
    });

    // Controls
    document.getElementById('playBtn').addEventListener('click', () => {
      playing = !playing;
      document.getElementById('playBtn').textContent = playing ? 'Pause' : 'Play';
      document.getElementById('playBtn').classList.toggle('active', playing);
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      currentFrame = 0;
      if (animation) {
        updatePointCloud(animation.frames[0]);
        updateInfo();
      }
    });

    document.getElementById('frameSlider').addEventListener('input', (e) => {
      currentFrame = parseInt(e.target.value);
      if (animation) {
        updatePointCloud(animation.frames[currentFrame]);
        updateInfo();
      }
    });

    document.getElementById('opacitySlider').addEventListener('input', (e) => {
      opacity = parseFloat(e.target.value);
      document.getElementById('opacityVal').textContent = opacity.toFixed(2);
      if (animation) updatePointCloud(animation.frames[currentFrame]);
    });

    document.getElementById('threshSlider').addEventListener('input', (e) => {
      threshold = parseFloat(e.target.value);
      document.getElementById('threshVal').textContent = threshold.toFixed(2);
      if (animation) updatePointCloud(animation.frames[currentFrame]);
    });

    // Animation loop
    let lastTime = 0;
    const frameInterval = 100; // ms between frames

    function animate(time) {
      requestAnimationFrame(animate);

      if (playing && animation && time - lastTime > frameInterval) {
        currentFrame = (currentFrame + 1) % animation.frameCount;
        updatePointCloud(animation.frames[currentFrame]);
        updateInfo();
        lastTime = time;
      }

      controls.update();
      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate(0);
  </script>
</body>
</html>
