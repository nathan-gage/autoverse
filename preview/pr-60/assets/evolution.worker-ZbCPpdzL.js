(function(){"use strict";let i=null,e=null,l=!1;function a(o){try{return o.getBestCandidateState()}catch{return null}}function r(o){self.postMessage(o)}async function g(o){if(console.log("[Worker] initWasm called with:",o),i){console.log("[Worker] WASM already loaded"),r({type:"ready"});return}try{console.log("[Worker] Importing WASM module..."),i=await import(o),console.log("[Worker] WASM module imported, keys:",Object.keys(i)),console.log("[Worker] Initializing WASM..."),await i.default(),console.log("[Worker] WASM initialized successfully"),r({type:"ready"})}catch(t){console.error("[Worker] Failed to load WASM:",t),r({type:"error",message:`Failed to load WASM: ${t}`})}}async function u(o,t){if(console.log("[Worker] runEvolution called"),!i){console.error("[Worker] WASM not initialized"),r({type:"error",message:"WASM not initialized"});return}if(l){console.error("[Worker] Evolution already running"),r({type:"error",message:"Evolution already running"});return}try{console.log("[Worker] Creating evolution engine..."),e&&(e.free(),e=null),e=new i.WasmEvolutionEngine(o),console.log("[Worker] Engine created successfully"),t&&e.setDefaultSeed(t),l=!0;let s=0;for(;l&&e&&!e.isComplete();){s++,console.log(`[Worker] Evolution step ${s}, isComplete=${e.isComplete()}`);const n=e.step();console.log(`[Worker] Step complete: gen=${n.generation}/${n.total_generations}, best=${n.best_fitness.toFixed(4)}`);const c=a(e);r({type:"progress",data:n,bestState:c}),await new Promise(W=>setTimeout(W,0))}if(console.log(`[Worker] Loop exited: isRunning=${l}, hasEngine=${!!e}, isComplete=${e?.isComplete()}`),l&&e){console.log("[Worker] Getting final result...");const n=e.getResult(),c=a(e);r({type:"complete",result:n,bestState:c}),console.log("[Worker] Evolution complete, result posted")}}catch(s){console.error("[Worker] Evolution error:",s);const n=s instanceof Error?s.message:String(s);r({type:"error",message:`Evolution error: ${n}`})}finally{console.log("[Worker] Evolution finished, cleaning up"),e&&(e.free(),e=null),l=!1}}function f(){e&&e.cancel(),l=!1}function p(){if(!e){r({type:"error",message:"No evolution engine"});return}const o=a(e);o&&r({type:"preview",state:o})}self.onmessage=async o=>{const t=o.data;switch(console.log("[Worker] Received message:",t.type),t.type){case"init":await g(t.wasmUrl);break;case"start":console.log("[Worker] Starting evolution with config length:",t.configJson.length),await u(t.configJson,t.seedJson);break;case"cancel":f();break;case"getPreview":p();break}}})();
